define("block_timetracker/screentime", ["exports"], function (_exports) {
  Object.defineProperty(_exports, "__esModule", { value: !0 }),
    (_exports.default = void 0);
  class Field {
    constructor(selector) {
      (this.selector = selector),
        (this.element = document.querySelector(selector)),
        this.updateMetrics();
    }
    updateMetrics() {
      const rect = this.element.getBoundingClientRect();
      (this.top = rect.top + window.scrollY),
        (this.bottom = rect.bottom + window.scrollY),
        (this.height = rect.height);
    }
    isOnScreen(viewport, percentOnScreen) {
      this.updateMetrics();
      const threshold = this.height * (percentOnScreen / 100);
      return (
        this.bottom - threshold > viewport.top &&
        this.top + threshold < viewport.bottom
      );
    }
  }
  class ScreenTime {
    constructor() {
      let options =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      (this.viewport = {
        top: window.scrollY,
        bottom: window.scrollY + window.innerHeight,
      }),
        (this.options = { ...ScreenTime.defaults, ...options }),
        (this.field = new Field(this.options.field.selector)),
        (this.timer = null),
        (this.log = {}),
        (this.reportTimer = 0),
        (this.reportIntervalId = null),
        (this.inactivityCounter = 0),
        (this.inactivityTimer = 0),
        (this.lastReport = 0),
        (this.reportInterval = 1e3 * this.options.reportInterval),
        document.addEventListener(
          "visibilitychange",
          this.handleVisibilityChange.bind(this)
        ),
        window.addEventListener("scroll", this.updateViewport.bind(this)),
        window.addEventListener("resize", this.updateViewport.bind(this)),
        this.start();
    }
    updateViewport() {
      (this.viewport.top = window.scrollY),
        (this.viewport.bottom = this.viewport.top + window.innerHeight);
    }
    static get defaults() {
      return {
        fields: [],
        percentOnScreen: 50,
        reportInterval: 10,
        googleAnalytics: !1,
        everySecondCallback: function () {},
        onInactivity: function () {},
        onStart: function () {},
        onReport: function () {},
      };
    }
    start() {
      this.options.onStart && this.options.onStart(),
        this.clearTimers(),
        (this.isActive = !0),
        (this.timer = setInterval(() => {
          this.checkFields(),
            this.inactivityTimer++,
            this.reportTimer++,
            this.inactivityTimer >= this.options.inactiveInterval &&
              this.handleInactivity(),
            this.reportTimer >= this.options.reportInterval && this.report();
        }, 1e3)),
        this.addActivityListeners();
    }
    addActivityListeners() {
      [
        "click",
        "scroll",
        "mousemove",
        "keypress",
        "touchstart",
        "touchmove",
        "wheel",
      ].forEach((event) => {
        window.addEventListener(event, () => this.resetInactivityTimer());
      }),
        ["beforeunload", "unload", "pagehide", "blur"].forEach((event) => {
          window.addEventListener(event, () => this.handleInactivity());
        });
    }
    resetInactivityTimer() {
      (this.inactivityTimer = 0),
        this.isActive || ((this.isActive = !0), this.start());
    }
    handleInactivity() {
      this.options.onInactivity && this.options.onInactivity(),
        (this.isActive = !1),
        this.report(),
        this.clearTimers();
    }
    clearTimers() {
      clearInterval(this.timer), (this.timer = null);
    }
    checkFields() {
      this.isActive &&
        (this.field.isOnScreen(this.viewport, this.options.percentOnScreen) &&
          (this.log[this.field.selector] =
            (this.log[this.field.selector] || 0) + 1),
        this.options.everySecondCallback &&
          this.options.everySecondCallback(this.log));
    }
    report() {
      if (!(Date.now() - this.lastReport >= 10)) return;
      Object.keys(this.log).length > 0 &&
        this.options.onReport &&
        this.options.onReport(this.log),
        (this.reportTimer = 0),
        (this.lastReport = Date.now());
    }
    handleVisibilityChange() {
      if ("hidden" === document.visibilityState)
        return this.stop(), void this.report();
      this.start();
    }
    stop() {
      clearInterval(this.timer), (this.timer = null);
    }
  }
  return (_exports.default = ScreenTime), _exports.default;
});

//# sourceMappingURL=screentime.min.js.map
